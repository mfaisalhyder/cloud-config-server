
package com.demo.fp.bookservice.cache;

import org.json.simple.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.RequestEntity;
import org.springframework.http.ResponseEntity;
import org.springframework.web.client.RestTemplate;

import com.demo.fp.bookservice.exception.BookException;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.experimental.SuperBuilder;
import lombok.extern.slf4j.Slf4j;

import java.net.URI;

@Slf4j
@NoArgsConstructor
public class BaseCacheHelper {

    private RestTemplate restTemplate;
    private CacheServiceProperties cacheServiceProperties;

    @Autowired
    private void setRestTemplate(RestTemplate restTemplate) {
        this.restTemplate = restTemplate;
    }

    @Autowired
    private void setCacheServiceProperties(CacheServiceProperties cacheServiceProperties) {
        this.cacheServiceProperties = cacheServiceProperties;
    }

    protected JSONObject invokeGetCache(final String appKey, final String key) {
        log.info("BaseCacheHelper.invokeGetCache() ---- STARTED");

        RequestEntity<CacheRequest> requestEntity = RequestEntity
                .post(URI.create(cacheServiceProperties.getUrl().concat("/get")))
                .accept(MediaType.APPLICATION_JSON)
                .headers(prepareHeaders())
                .body(CacheRequest.builder().appKey(appKey).key(key).build());

        ResponseEntity<CacheResponse> responseEntity = restTemplate.exchange(requestEntity, CacheResponse.class);
        if (responseEntity.getBody() == null)
            throw new BookException(HttpStatus.NO_CONTENT, HttpStatus.NO_CONTENT.getReasonPhrase(), "No Data in response");

        JSONObject jsonObject = responseEntity.getBody().getData();

        log.info("BaseCacheHelper.invokeGetCache() ---- ENDED");

        return jsonObject;
    }

    protected boolean invokeSaveCache(final String appKey, final String key, final JSONObject jsonObject, final Long ttl) {
        log.info("BaseCacheHelper.invokeSaveCache() ---- STARTED");

        RequestEntity<CacheRequest> requestEntity = RequestEntity
                .post(URI.create(cacheServiceProperties.getUrl()))
                .accept(MediaType.APPLICATION_JSON)
                .headers(prepareHeaders())
                .body(CacheRequest.builder().appKey(appKey).key(key).value(jsonObject).ttl(ttl).build());

        ResponseEntity<BaseResponse> responseEntity = restTemplate.exchange(requestEntity, BaseResponse.class);
        if (responseEntity.getBody() == null)
            throw new BookException(HttpStatus.NO_CONTENT, HttpStatus.NO_CONTENT.getReasonPhrase(), "No Data in response");

        boolean response = responseEntity.getBody().getSuccess();

        log.info("BaseCacheHelper.invokeSaveCache() ---- ENDED");

        return response;
    }

    private HttpHeaders prepareHeaders() {
        HttpHeaders httpHeaders = new HttpHeaders();
        httpHeaders.add("Authorization", "Basic " + cacheServiceProperties.getApiKey());

        return httpHeaders;
    }

    @NoArgsConstructor
    @AllArgsConstructor
    @Getter
    @Builder
    private static class CacheRequest {
        private String appKey;
        private String key;
        private JSONObject value;
        private Long ttl;
    }

    @NoArgsConstructor
    @AllArgsConstructor
    @Getter
    @SuperBuilder
    private static class CacheResponse extends BaseCacheHelper.BaseResponse {
        // private Boolean success
        // private String message;
        private JSONObject data;
    }

    @NoArgsConstructor
    @AllArgsConstructor
    @Getter
    @SuperBuilder
    private static class BaseResponse {
        private Boolean success;
        private String message;
    }

}


/////

package com.demo.fp.bookservice.cache;

import org.json.simple.JSONObject;
import org.springframework.stereotype.Service;

import com.demo.fp.bookservice.util.JsonUtil;
import com.fasterxml.jackson.core.type.TypeReference;
import lombok.extern.slf4j.Slf4j;

import java.io.IOException;
import java.util.Map;

@Slf4j
@Service
public class CacheHelper extends BaseCacheHelper {

    public <T> T getData(final String appKey, final String key, final Class<T> classType) {
        log.info("CacheHelper.getData() ---- Started fetching data for appKey: {}, key: {}", appKey, key);

        T data = null;
        try {
            JSONObject jsonObject = invokeGetCache(appKey, key);
            if (jsonObject != null) {
                log.info("Record found in cache");
                data = JsonUtil.fromJson(jsonObject, classType);
            }
        } catch (IOException ioException) {
            log.error("CacheHelper.getData() ---- Unable to get Data\n", ioException);
        }

        log.info("CacheHelper.getData() ---- Ended fetching data for appKey: {}, key: {}", appKey, key);

        return data;
    }

    public boolean saveData(final String appKey, final String key, final Object data, final Long ttl) {
        log.info("CacheHelper.saveData() ---- Started saving data for appKey: {}, key: {}", appKey, key);

        Map<String, Object> dataMap = JsonUtil.fromObject(data, new TypeReference<Map<String, Object>>() {
        });

        JSONObject jsonObject = new JSONObject(dataMap);

        boolean response = invokeSaveCache(appKey, key, jsonObject, ttl);

        log.info("CacheHelper.saveData() ---- Ended saving data for appKey: {}, key: {}", appKey, key);

        return response;
    }

}

////
package com.demo.fp.bookservice.cache;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.cloud.context.config.annotation.RefreshScope;
import org.springframework.context.annotation.Configuration;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@Configuration
@ConfigurationProperties("cache-service")
@RefreshScope
public class CacheServiceProperties {

    private String apiKey;
    private String url;

}
